{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nexport const useWebSocket = userId => {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const [messages, setMessages] = useState([]);\n  const [lastActivity, setLastActivity] = useState(null);\n  const reconnectTimeoutRef = useRef();\n  const heartbeatIntervalRef = useRef();\n  const reconnectAttemptsRef = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectDelay = 3000; // 3 seconds\n  const heartbeatInterval = 30000; // 30 seconds\n  const idleTimeout = 300000; // 5 minutes\n\n  const wsUrl = `${process.env.REACT_APP_WS_URL || 'ws://localhost:8000'}/ws/chat/${userId}`;\n  const connect = useCallback(() => {\n    if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.OPEN) {\n      return;\n    }\n    setConnectionStatus('connecting');\n    console.log('ðŸ”Œ Connecting to WebSocket...');\n    try {\n      const newSocket = new WebSocket(wsUrl);\n      newSocket.onopen = () => {\n        console.log('âœ… WebSocket connected');\n        setSocket(newSocket);\n        setIsConnected(true);\n        setConnectionStatus('connected');\n        setLastActivity(new Date());\n        reconnectAttemptsRef.current = 0;\n\n        // Start heartbeat\n        startHeartbeat(newSocket);\n      };\n      newSocket.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          setMessages(prev => [...prev, data]);\n          setLastActivity(new Date());\n          console.log('ðŸ“¨ Message received:', data);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n      newSocket.onclose = event => {\n        console.log('ðŸ”Œ WebSocket disconnected:', event.code, event.reason);\n        setSocket(null);\n        setIsConnected(false);\n        setConnectionStatus('disconnected');\n\n        // Clear heartbeat\n        if (heartbeatIntervalRef.current) {\n          clearInterval(heartbeatIntervalRef.current);\n        }\n\n        // Attempt reconnection if not a manual close\n        if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {\n          scheduleReconnect();\n        }\n      };\n      newSocket.onerror = error => {\n        console.error('âŒ WebSocket error:', error);\n        setConnectionStatus('disconnected');\n      };\n    } catch (error) {\n      console.error('âŒ Failed to create WebSocket:', error);\n      setConnectionStatus('disconnected');\n      scheduleReconnect();\n    }\n  }, [wsUrl, socket]);\n  const scheduleReconnect = useCallback(() => {\n    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n      console.log('âŒ Max reconnection attempts reached');\n      setConnectionStatus('disconnected');\n      return;\n    }\n    reconnectAttemptsRef.current++;\n    setConnectionStatus('reconnecting');\n    console.log(`ðŸ”„ Scheduling reconnect attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts} in ${reconnectDelay}ms`);\n    reconnectTimeoutRef.current = setTimeout(() => {\n      connect();\n    }, reconnectDelay * reconnectAttemptsRef.current); // Exponential backoff\n  }, [connect]);\n  const startHeartbeat = useCallback(ws => {\n    heartbeatIntervalRef.current = setInterval(() => {\n      if (ws.readyState === WebSocket.OPEN) {\n        // Send ping message\n        ws.send(JSON.stringify({\n          type: 'ping',\n          timestamp: Date.now()\n        }));\n        console.log('ðŸ’“ Heartbeat sent');\n\n        // Check for idle timeout\n        const now = new Date();\n        if (lastActivity && now.getTime() - lastActivity.getTime() > idleTimeout) {\n          console.log('â° Connection idle for too long, refreshing...');\n          ws.close(1000, 'Idle timeout');\n          connect();\n        }\n      }\n    }, heartbeatInterval);\n  }, [lastActivity, connect]);\n  const sendMessage = useCallback(message => {\n    if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.OPEN) {\n      const messageData = {\n        message,\n        timestamp: Date.now(),\n        userId\n      };\n      socket.send(JSON.stringify(messageData));\n      setLastActivity(new Date());\n      console.log('ðŸ“¤ Message sent:', message);\n    } else {\n      console.warn('âš ï¸ WebSocket not connected, attempting to reconnect...');\n      connect();\n    }\n  }, [socket, userId, connect]);\n  const reconnect = useCallback(() => {\n    console.log('ðŸ”„ Manual reconnection triggered');\n    reconnectAttemptsRef.current = 0;\n\n    // Close existing connection\n    if (socket) {\n      socket.close(1000, 'Manual reconnect');\n    }\n\n    // Clear timeouts\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n\n    // Reconnect\n    setTimeout(connect, 100);\n  }, [socket, connect]);\n\n  // Initialize connection\n  useEffect(() => {\n    connect();\n\n    // Cleanup on unmount\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (heartbeatIntervalRef.current) {\n        clearInterval(heartbeatIntervalRef.current);\n      }\n      if (socket) {\n        socket.close(1000, 'Component unmount');\n      }\n    };\n  }, []);\n\n  // Handle page visibility changes\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible' && !isConnected) {\n        console.log('ðŸ‘ï¸ Page became visible, checking connection...');\n        reconnect();\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);\n  }, [isConnected, reconnect]);\n\n  // Handle online/offline events\n  useEffect(() => {\n    const handleOnline = () => {\n      console.log('ðŸŒ Network back online, reconnecting...');\n      reconnect();\n    };\n    const handleOffline = () => {\n      console.log('ðŸ“µ Network offline');\n      setConnectionStatus('disconnected');\n    };\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, [reconnect]);\n  return {\n    socket,\n    isConnected,\n    connectionStatus,\n    sendMessage,\n    messages,\n    reconnect,\n    lastActivity\n  };\n};\n_s(useWebSocket, \"E2KYLWNhlwJ1KR9Dv/4gu/+e+7c=\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useWebSocket","userId","_s","socket","setSocket","isConnected","setIsConnected","connectionStatus","setConnectionStatus","messages","setMessages","lastActivity","setLastActivity","reconnectTimeoutRef","heartbeatIntervalRef","reconnectAttemptsRef","maxReconnectAttempts","reconnectDelay","heartbeatInterval","idleTimeout","wsUrl","process","env","REACT_APP_WS_URL","connect","readyState","WebSocket","OPEN","console","log","newSocket","onopen","Date","current","startHeartbeat","onmessage","event","data","JSON","parse","prev","error","onclose","code","reason","clearInterval","scheduleReconnect","onerror","setTimeout","ws","setInterval","send","stringify","type","timestamp","now","getTime","close","sendMessage","message","messageData","warn","reconnect","clearTimeout","handleVisibilityChange","document","visibilityState","addEventListener","removeEventListener","handleOnline","handleOffline","window"],"sources":["D:/Navikenz/pro/navihire/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\r\n\r\ninterface WebSocketMessage {\r\n  type: string;\r\n  content: string;\r\n  agent?: string;\r\n  task_progress?: any;\r\n}\r\n\r\ninterface UseWebSocketReturn {\r\n  socket: WebSocket | null;\r\n  isConnected: boolean;\r\n  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'reconnecting';\r\n  sendMessage: (message: string) => void;\r\n  messages: WebSocketMessage[];\r\n  reconnect: () => void;\r\n  lastActivity: Date | null;\r\n}\r\n\r\nexport const useWebSocket = (userId: string): UseWebSocketReturn => {\r\n  const [socket, setSocket] = useState<WebSocket | null>(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'reconnecting'>('disconnected');\r\n  const [messages, setMessages] = useState<WebSocketMessage[]>([]);\r\n  const [lastActivity, setLastActivity] = useState<Date | null>(null);\r\n  \r\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();\r\n  const heartbeatIntervalRef = useRef<NodeJS.Timeout>();\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const maxReconnectAttempts = 5;\r\n  const reconnectDelay = 3000; // 3 seconds\r\n  const heartbeatInterval = 30000; // 30 seconds\r\n  const idleTimeout = 300000; // 5 minutes\r\n\r\n  const wsUrl = `${process.env.REACT_APP_WS_URL || 'ws://localhost:8000'}/ws/chat/${userId}`;\r\n\r\n  const connect = useCallback(() => {\r\n    if (socket?.readyState === WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    setConnectionStatus('connecting');\r\n    console.log('ðŸ”Œ Connecting to WebSocket...');\r\n\r\n    try {\r\n      const newSocket = new WebSocket(wsUrl);\r\n\r\n      newSocket.onopen = () => {\r\n        console.log('âœ… WebSocket connected');\r\n        setSocket(newSocket);\r\n        setIsConnected(true);\r\n        setConnectionStatus('connected');\r\n        setLastActivity(new Date());\r\n        reconnectAttemptsRef.current = 0;\r\n        \r\n        // Start heartbeat\r\n        startHeartbeat(newSocket);\r\n      };\r\n\r\n      newSocket.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          setMessages(prev => [...prev, data]);\r\n          setLastActivity(new Date());\r\n          console.log('ðŸ“¨ Message received:', data);\r\n        } catch (error) {\r\n          console.error('Error parsing WebSocket message:', error);\r\n        }\r\n      };\r\n\r\n      newSocket.onclose = (event) => {\r\n        console.log('ðŸ”Œ WebSocket disconnected:', event.code, event.reason);\r\n        setSocket(null);\r\n        setIsConnected(false);\r\n        setConnectionStatus('disconnected');\r\n        \r\n        // Clear heartbeat\r\n        if (heartbeatIntervalRef.current) {\r\n          clearInterval(heartbeatIntervalRef.current);\r\n        }\r\n\r\n        // Attempt reconnection if not a manual close\r\n        if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {\r\n          scheduleReconnect();\r\n        }\r\n      };\r\n\r\n      newSocket.onerror = (error) => {\r\n        console.error('âŒ WebSocket error:', error);\r\n        setConnectionStatus('disconnected');\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('âŒ Failed to create WebSocket:', error);\r\n      setConnectionStatus('disconnected');\r\n      scheduleReconnect();\r\n    }\r\n  }, [wsUrl, socket]);\r\n\r\n  const scheduleReconnect = useCallback(() => {\r\n    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\r\n      console.log('âŒ Max reconnection attempts reached');\r\n      setConnectionStatus('disconnected');\r\n      return;\r\n    }\r\n\r\n    reconnectAttemptsRef.current++;\r\n    setConnectionStatus('reconnecting');\r\n    \r\n    console.log(`ðŸ”„ Scheduling reconnect attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts} in ${reconnectDelay}ms`);\r\n    \r\n    reconnectTimeoutRef.current = setTimeout(() => {\r\n      connect();\r\n    }, reconnectDelay * reconnectAttemptsRef.current); // Exponential backoff\r\n  }, [connect]);\r\n\r\n  const startHeartbeat = useCallback((ws: WebSocket) => {\r\n    heartbeatIntervalRef.current = setInterval(() => {\r\n      if (ws.readyState === WebSocket.OPEN) {\r\n        // Send ping message\r\n        ws.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));\r\n        console.log('ðŸ’“ Heartbeat sent');\r\n        \r\n        // Check for idle timeout\r\n        const now = new Date();\r\n        if (lastActivity && (now.getTime() - lastActivity.getTime()) > idleTimeout) {\r\n          console.log('â° Connection idle for too long, refreshing...');\r\n          ws.close(1000, 'Idle timeout');\r\n          connect();\r\n        }\r\n      }\r\n    }, heartbeatInterval);\r\n  }, [lastActivity, connect]);\r\n\r\n  const sendMessage = useCallback((message: string) => {\r\n    if (socket?.readyState === WebSocket.OPEN) {\r\n      const messageData = {\r\n        message,\r\n        timestamp: Date.now(),\r\n        userId\r\n      };\r\n      socket.send(JSON.stringify(messageData));\r\n      setLastActivity(new Date());\r\n      console.log('ðŸ“¤ Message sent:', message);\r\n    } else {\r\n      console.warn('âš ï¸ WebSocket not connected, attempting to reconnect...');\r\n      connect();\r\n    }\r\n  }, [socket, userId, connect]);\r\n\r\n  const reconnect = useCallback(() => {\r\n    console.log('ðŸ”„ Manual reconnection triggered');\r\n    reconnectAttemptsRef.current = 0;\r\n    \r\n    // Close existing connection\r\n    if (socket) {\r\n      socket.close(1000, 'Manual reconnect');\r\n    }\r\n    \r\n    // Clear timeouts\r\n    if (reconnectTimeoutRef.current) {\r\n      clearTimeout(reconnectTimeoutRef.current);\r\n    }\r\n    \r\n    // Reconnect\r\n    setTimeout(connect, 100);\r\n  }, [socket, connect]);\r\n\r\n  // Initialize connection\r\n  useEffect(() => {\r\n    connect();\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      if (heartbeatIntervalRef.current) {\r\n        clearInterval(heartbeatIntervalRef.current);\r\n      }\r\n      if (socket) {\r\n        socket.close(1000, 'Component unmount');\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Handle page visibility changes\r\n  useEffect(() => {\r\n    const handleVisibilityChange = () => {\r\n      if (document.visibilityState === 'visible' && !isConnected) {\r\n        console.log('ðŸ‘ï¸ Page became visible, checking connection...');\r\n        reconnect();\r\n      }\r\n    };\r\n\r\n    document.addEventListener('visibilitychange', handleVisibilityChange);\r\n    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n  }, [isConnected, reconnect]);\r\n\r\n  // Handle online/offline events\r\n  useEffect(() => {\r\n    const handleOnline = () => {\r\n      console.log('ðŸŒ Network back online, reconnecting...');\r\n      reconnect();\r\n    };\r\n\r\n    const handleOffline = () => {\r\n      console.log('ðŸ“µ Network offline');\r\n      setConnectionStatus('disconnected');\r\n    };\r\n\r\n    window.addEventListener('online', handleOnline);\r\n    window.addEventListener('offline', handleOffline);\r\n\r\n    return () => {\r\n      window.removeEventListener('online', handleOnline);\r\n      window.removeEventListener('offline', handleOffline);\r\n    };\r\n  }, [reconnect]);\r\n\r\n  return {\r\n    socket,\r\n    isConnected,\r\n    connectionStatus,\r\n    sendMessage,\r\n    messages,\r\n    reconnect,\r\n    lastActivity\r\n  };\r\n};"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;AAmBhE,OAAO,MAAMC,YAAY,GAAIC,MAAc,IAAyB;EAAAC,EAAA;EAClE,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGR,QAAQ,CAAmB,IAAI,CAAC;EAC5D,MAAM,CAACS,WAAW,EAAEC,cAAc,CAAC,GAAGV,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACW,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGZ,QAAQ,CAA+D,cAAc,CAAC;EACtI,MAAM,CAACa,QAAQ,EAAEC,WAAW,CAAC,GAAGd,QAAQ,CAAqB,EAAE,CAAC;EAChE,MAAM,CAACe,YAAY,EAAEC,eAAe,CAAC,GAAGhB,QAAQ,CAAc,IAAI,CAAC;EAEnE,MAAMiB,mBAAmB,GAAGf,MAAM,CAAiB,CAAC;EACpD,MAAMgB,oBAAoB,GAAGhB,MAAM,CAAiB,CAAC;EACrD,MAAMiB,oBAAoB,GAAGjB,MAAM,CAAC,CAAC,CAAC;EACtC,MAAMkB,oBAAoB,GAAG,CAAC;EAC9B,MAAMC,cAAc,GAAG,IAAI,CAAC,CAAC;EAC7B,MAAMC,iBAAiB,GAAG,KAAK,CAAC,CAAC;EACjC,MAAMC,WAAW,GAAG,MAAM,CAAC,CAAC;;EAE5B,MAAMC,KAAK,GAAG,GAAGC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAAI,qBAAqB,YAAYtB,MAAM,EAAE;EAE1F,MAAMuB,OAAO,GAAGzB,WAAW,CAAC,MAAM;IAChC,IAAI,CAAAI,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEsB,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;MACzC;IACF;IAEAnB,mBAAmB,CAAC,YAAY,CAAC;IACjCoB,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;IAE5C,IAAI;MACF,MAAMC,SAAS,GAAG,IAAIJ,SAAS,CAACN,KAAK,CAAC;MAEtCU,SAAS,CAACC,MAAM,GAAG,MAAM;QACvBH,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;QACpCzB,SAAS,CAAC0B,SAAS,CAAC;QACpBxB,cAAc,CAAC,IAAI,CAAC;QACpBE,mBAAmB,CAAC,WAAW,CAAC;QAChCI,eAAe,CAAC,IAAIoB,IAAI,CAAC,CAAC,CAAC;QAC3BjB,oBAAoB,CAACkB,OAAO,GAAG,CAAC;;QAEhC;QACAC,cAAc,CAACJ,SAAS,CAAC;MAC3B,CAAC;MAEDA,SAAS,CAACK,SAAS,GAAIC,KAAK,IAAK;QAC/B,IAAI;UACF,MAAMC,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,CAACC,IAAI,CAAC;UACnC3B,WAAW,CAAC8B,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAEH,IAAI,CAAC,CAAC;UACpCzB,eAAe,CAAC,IAAIoB,IAAI,CAAC,CAAC,CAAC;UAC3BJ,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEQ,IAAI,CAAC;QAC3C,CAAC,CAAC,OAAOI,KAAK,EAAE;UACdb,OAAO,CAACa,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;QAC1D;MACF,CAAC;MAEDX,SAAS,CAACY,OAAO,GAAIN,KAAK,IAAK;QAC7BR,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAEO,KAAK,CAACO,IAAI,EAAEP,KAAK,CAACQ,MAAM,CAAC;QACnExC,SAAS,CAAC,IAAI,CAAC;QACfE,cAAc,CAAC,KAAK,CAAC;QACrBE,mBAAmB,CAAC,cAAc,CAAC;;QAEnC;QACA,IAAIM,oBAAoB,CAACmB,OAAO,EAAE;UAChCY,aAAa,CAAC/B,oBAAoB,CAACmB,OAAO,CAAC;QAC7C;;QAEA;QACA,IAAIG,KAAK,CAACO,IAAI,KAAK,IAAI,IAAI5B,oBAAoB,CAACkB,OAAO,GAAGjB,oBAAoB,EAAE;UAC9E8B,iBAAiB,CAAC,CAAC;QACrB;MACF,CAAC;MAEDhB,SAAS,CAACiB,OAAO,GAAIN,KAAK,IAAK;QAC7Bb,OAAO,CAACa,KAAK,CAAC,oBAAoB,EAAEA,KAAK,CAAC;QAC1CjC,mBAAmB,CAAC,cAAc,CAAC;MACrC,CAAC;IAEH,CAAC,CAAC,OAAOiC,KAAK,EAAE;MACdb,OAAO,CAACa,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;MACrDjC,mBAAmB,CAAC,cAAc,CAAC;MACnCsC,iBAAiB,CAAC,CAAC;IACrB;EACF,CAAC,EAAE,CAAC1B,KAAK,EAAEjB,MAAM,CAAC,CAAC;EAEnB,MAAM2C,iBAAiB,GAAG/C,WAAW,CAAC,MAAM;IAC1C,IAAIgB,oBAAoB,CAACkB,OAAO,IAAIjB,oBAAoB,EAAE;MACxDY,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;MAClDrB,mBAAmB,CAAC,cAAc,CAAC;MACnC;IACF;IAEAO,oBAAoB,CAACkB,OAAO,EAAE;IAC9BzB,mBAAmB,CAAC,cAAc,CAAC;IAEnCoB,OAAO,CAACC,GAAG,CAAC,mCAAmCd,oBAAoB,CAACkB,OAAO,IAAIjB,oBAAoB,OAAOC,cAAc,IAAI,CAAC;IAE7HJ,mBAAmB,CAACoB,OAAO,GAAGe,UAAU,CAAC,MAAM;MAC7CxB,OAAO,CAAC,CAAC;IACX,CAAC,EAAEP,cAAc,GAAGF,oBAAoB,CAACkB,OAAO,CAAC,CAAC,CAAC;EACrD,CAAC,EAAE,CAACT,OAAO,CAAC,CAAC;EAEb,MAAMU,cAAc,GAAGnC,WAAW,CAAEkD,EAAa,IAAK;IACpDnC,oBAAoB,CAACmB,OAAO,GAAGiB,WAAW,CAAC,MAAM;MAC/C,IAAID,EAAE,CAACxB,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;QACpC;QACAsB,EAAE,CAACE,IAAI,CAACb,IAAI,CAACc,SAAS,CAAC;UAAEC,IAAI,EAAE,MAAM;UAAEC,SAAS,EAAEtB,IAAI,CAACuB,GAAG,CAAC;QAAE,CAAC,CAAC,CAAC;QAChE3B,OAAO,CAACC,GAAG,CAAC,mBAAmB,CAAC;;QAEhC;QACA,MAAM0B,GAAG,GAAG,IAAIvB,IAAI,CAAC,CAAC;QACtB,IAAIrB,YAAY,IAAK4C,GAAG,CAACC,OAAO,CAAC,CAAC,GAAG7C,YAAY,CAAC6C,OAAO,CAAC,CAAC,GAAIrC,WAAW,EAAE;UAC1ES,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;UAC5DoB,EAAE,CAACQ,KAAK,CAAC,IAAI,EAAE,cAAc,CAAC;UAC9BjC,OAAO,CAAC,CAAC;QACX;MACF;IACF,CAAC,EAAEN,iBAAiB,CAAC;EACvB,CAAC,EAAE,CAACP,YAAY,EAAEa,OAAO,CAAC,CAAC;EAE3B,MAAMkC,WAAW,GAAG3D,WAAW,CAAE4D,OAAe,IAAK;IACnD,IAAI,CAAAxD,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEsB,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;MACzC,MAAMiC,WAAW,GAAG;QAClBD,OAAO;QACPL,SAAS,EAAEtB,IAAI,CAACuB,GAAG,CAAC,CAAC;QACrBtD;MACF,CAAC;MACDE,MAAM,CAACgD,IAAI,CAACb,IAAI,CAACc,SAAS,CAACQ,WAAW,CAAC,CAAC;MACxChD,eAAe,CAAC,IAAIoB,IAAI,CAAC,CAAC,CAAC;MAC3BJ,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAE8B,OAAO,CAAC;IAC1C,CAAC,MAAM;MACL/B,OAAO,CAACiC,IAAI,CAAC,wDAAwD,CAAC;MACtErC,OAAO,CAAC,CAAC;IACX;EACF,CAAC,EAAE,CAACrB,MAAM,EAAEF,MAAM,EAAEuB,OAAO,CAAC,CAAC;EAE7B,MAAMsC,SAAS,GAAG/D,WAAW,CAAC,MAAM;IAClC6B,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;IAC/Cd,oBAAoB,CAACkB,OAAO,GAAG,CAAC;;IAEhC;IACA,IAAI9B,MAAM,EAAE;MACVA,MAAM,CAACsD,KAAK,CAAC,IAAI,EAAE,kBAAkB,CAAC;IACxC;;IAEA;IACA,IAAI5C,mBAAmB,CAACoB,OAAO,EAAE;MAC/B8B,YAAY,CAAClD,mBAAmB,CAACoB,OAAO,CAAC;IAC3C;;IAEA;IACAe,UAAU,CAACxB,OAAO,EAAE,GAAG,CAAC;EAC1B,CAAC,EAAE,CAACrB,MAAM,EAAEqB,OAAO,CAAC,CAAC;;EAErB;EACA3B,SAAS,CAAC,MAAM;IACd2B,OAAO,CAAC,CAAC;;IAET;IACA,OAAO,MAAM;MACX,IAAIX,mBAAmB,CAACoB,OAAO,EAAE;QAC/B8B,YAAY,CAAClD,mBAAmB,CAACoB,OAAO,CAAC;MAC3C;MACA,IAAInB,oBAAoB,CAACmB,OAAO,EAAE;QAChCY,aAAa,CAAC/B,oBAAoB,CAACmB,OAAO,CAAC;MAC7C;MACA,IAAI9B,MAAM,EAAE;QACVA,MAAM,CAACsD,KAAK,CAAC,IAAI,EAAE,mBAAmB,CAAC;MACzC;IACF,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA5D,SAAS,CAAC,MAAM;IACd,MAAMmE,sBAAsB,GAAGA,CAAA,KAAM;MACnC,IAAIC,QAAQ,CAACC,eAAe,KAAK,SAAS,IAAI,CAAC7D,WAAW,EAAE;QAC1DuB,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;QAC9DiC,SAAS,CAAC,CAAC;MACb;IACF,CAAC;IAEDG,QAAQ,CAACE,gBAAgB,CAAC,kBAAkB,EAAEH,sBAAsB,CAAC;IACrE,OAAO,MAAMC,QAAQ,CAACG,mBAAmB,CAAC,kBAAkB,EAAEJ,sBAAsB,CAAC;EACvF,CAAC,EAAE,CAAC3D,WAAW,EAAEyD,SAAS,CAAC,CAAC;;EAE5B;EACAjE,SAAS,CAAC,MAAM;IACd,MAAMwE,YAAY,GAAGA,CAAA,KAAM;MACzBzC,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;MACtDiC,SAAS,CAAC,CAAC;IACb,CAAC;IAED,MAAMQ,aAAa,GAAGA,CAAA,KAAM;MAC1B1C,OAAO,CAACC,GAAG,CAAC,oBAAoB,CAAC;MACjCrB,mBAAmB,CAAC,cAAc,CAAC;IACrC,CAAC;IAED+D,MAAM,CAACJ,gBAAgB,CAAC,QAAQ,EAAEE,YAAY,CAAC;IAC/CE,MAAM,CAACJ,gBAAgB,CAAC,SAAS,EAAEG,aAAa,CAAC;IAEjD,OAAO,MAAM;MACXC,MAAM,CAACH,mBAAmB,CAAC,QAAQ,EAAEC,YAAY,CAAC;MAClDE,MAAM,CAACH,mBAAmB,CAAC,SAAS,EAAEE,aAAa,CAAC;IACtD,CAAC;EACH,CAAC,EAAE,CAACR,SAAS,CAAC,CAAC;EAEf,OAAO;IACL3D,MAAM;IACNE,WAAW;IACXE,gBAAgB;IAChBmD,WAAW;IACXjD,QAAQ;IACRqD,SAAS;IACTnD;EACF,CAAC;AACH,CAAC;AAACT,EAAA,CAlNWF,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}